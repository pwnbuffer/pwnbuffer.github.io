<!DOCTYPE html>
<html lang="pt-br">

<head>
  <title>
  Arquitetura do Windows ¬∑ pwnbuffer
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="pwnbuffer">
<meta name="description" content="Arquitetura do Windows para desenvolvimento de malware">
<meta name="keywords" content="team brazuca!">



  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Arquitetura do Windows">
  <meta name="twitter:description" content="Arquitetura do Windows para desenvolvimento de malware">

<meta property="og:url" content="https://pwnbuffer.org/posts/tteuw/windows_architecture/">
  <meta property="og:site_name" content="pwnbuffer">
  <meta property="og:title" content="Arquitetura do Windows">
  <meta property="og:description" content="Arquitetura do Windows para desenvolvimento de malware">
  <meta property="og:locale" content="pt_br">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-02-08T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-02-08T00:00:00+00:00">
    <meta property="article:tag" content="Maldev">
    <meta property="article:tag" content="Windows">
    <meta property="article:tag" content="Malware">
    <meta property="article:tag" content="Architecture">
    <meta property="article:tag" content="Memory">




<link rel="canonical" href="https://pwnbuffer.org/posts/tteuw/windows_architecture/">


<link rel="preload" href="https://pwnbuffer.org/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="https://pwnbuffer.org/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="https://pwnbuffer.org/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="https://pwnbuffer.org/css/coder.min.b886fe0d9034709648f91f4ce178f51dd367d9350f82dd1132d54fd69bfca66f.css" integrity="sha256-uIb&#43;DZA0cJZI&#43;R9M4Xj1HdNn2TUPgt0RMtVP1pv8pm8=" crossorigin="anonymous" media="screen" />






  
    
    
    <link rel="stylesheet" href="https://pwnbuffer.org/css/coder-dark.min.165f5fe7c98269a5cfc54f81472e0f84ebc32d92bbe6c9db1f06962b0817bda1.css" integrity="sha256-Fl9f58mCaaXPxU&#43;BRy4PhOvDLZK75snbHwaWKwgXvaE=" crossorigin="anonymous" media="screen" />
  



 




<link rel="icon" type="image/svg+xml" href="https://pwnbuffer.org/img/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="https://pwnbuffer.org/img/favicon-32x32.ico" sizes="32x32">
<link rel="icon" type="image/png" href="https://pwnbuffer.org/img/favicon-16x16.ico" sizes="16x16">

<link rel="apple-touch-icon" href="https://pwnbuffer.org/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://pwnbuffer.org/images/apple-touch-icon.png">

<link rel="manifest" href="https://pwnbuffer.org/site.webmanifest">
<link rel="mask-icon" href="https://pwnbuffer.org/images/safari-pinned-tab.svg" color="#5bbad5">









</head>






<body class="preload-transitions colorscheme-dark">
  

  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    
    <a class="navigation-title" href="https://pwnbuffer.org/">
      pwnbuffer
    </a>
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="https://pwnbuffer.org/about/">Sobre</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="https://pwnbuffer.org/posts/">Artigos</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="https://pwnbuffer.org/categories/">Categorias</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="https://pwnbuffer.org/members/">Membros</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="https://pwnbuffer.org/wallpapers/">Wallpapers</a>
            </li>
          
        
        
          
          
          
            
              
                <li class="navigation-item menu-separator">
                  <span>|</span>
                </li>
                
              
              <li class="navigation-item">
                <a href="https://pwnbuffer.org/en/posts/tteuw/windows_architecture/">üá∫üá∏</a>
              </li>
            
          
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="https://pwnbuffer.org/posts/tteuw/windows_architecture/">
              Arquitetura do Windows
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa-solid fa-calendar" aria-hidden="true"></i>
              <time datetime="2025-02-08T00:00:00Z">
                fevereiro 8, 2025
              </time>
            </span>
            <span class="reading-time">
              <i class="fa-solid fa-clock" aria-hidden="true"></i>
              13 minutos de leitura
            </span>
          </div>
          <div class="authors">
  <i class="fa-solid fa-user" aria-hidden="true"></i>
    <a href="https://pwnbuffer.org/authors/tteuw/">Tteuw</a>
      <span class="separator">‚Ä¢</span>
    <a href="https://pwnbuffer.org/authors/slayer/">Slayer</a></div>

          <div class="categories">
  <i class="fa-solid fa-folder" aria-hidden="true"></i>
    <a href="https://pwnbuffer.org/categories/low-level/">Low-Level</a>
      <span class="separator">‚Ä¢</span>
    <a href="https://pwnbuffer.org/categories/windows/">Windows</a>
      <span class="separator">‚Ä¢</span>
    <a href="https://pwnbuffer.org/categories/maldev/">Maldev</a></div>

          <div class="tags">
  <i class="fa-solid fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="https://pwnbuffer.org/tags/maldev/">Maldev</a>
    </span>
      <span class="separator">‚Ä¢</span>
    <span class="tag">
      <a href="https://pwnbuffer.org/tags/windows/">Windows</a>
    </span>
      <span class="separator">‚Ä¢</span>
    <span class="tag">
      <a href="https://pwnbuffer.org/tags/malware/">Malware</a>
    </span>
      <span class="separator">‚Ä¢</span>
    <span class="tag">
      <a href="https://pwnbuffer.org/tags/architecture/">Architecture</a>
    </span>
      <span class="separator">‚Ä¢</span>
    <span class="tag">
      <a href="https://pwnbuffer.org/tags/memory/">Memory</a>
    </span></div>

        </div>
      </header>

      <div class="post-content">
        
        <p><strong>Pr√©-requisitos:</strong>
Os requisitos para os usu√°rios que planejam aprender Desenvolvimento de Malware s√£o, primeiro de tudo, os fundamentos de programa√ß√£o, j√° que a maioria das vezes √© lidado com a linguagem de programa√ß√£o C. √â um requisito que voc√™ esteja familiarizado com os fundamentos de C.</p>
<p>Ent√£o, o que √© realmente <strong>Arquitetura do Windows</strong>?
√â o que acontece por tr√°s dos processos e aplicativos do Windows, a estrutura interna do sistema operacional Windows, envolvendo camadas como hardware, kernel, servi√ßos executivos e DLLs de subsistema.</p>
<h1 id="arquitetura-do-windows">
  Arquitetura do Windows
  <a class="heading-link" href="#arquitetura-do-windows">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link para o cabe√ßalho"></i>
    <span class="sr-only">Link para o cabe√ßalho</span>
  </a>
</h1>
<p>Primeiro, vamos esclarecer alguns termos:</p>
<p>O que √© um <strong>processador</strong>?</p>
<p>O processador √© a CPU, o hardware que executa as instru√ß√µes.
Ele <strong>busca</strong>, <strong>decodifica</strong> e <strong>executa</strong> instru√ß√µes de m√°quina, realiza <strong>opera√ß√µes aritm√©ticas</strong> e <strong>l√≥gicas</strong>, al√©m de gerenciar o fluxo de controle entre os diversos programas (ou processos) que est√£o em execu√ß√£o na m√°quina.</p>
<p>O que √© um <strong>aplicativo</strong>?</p>
<p>Um aplicativo √© um programa que roda no sistema operacional, utilizando seus recursos para funcionar.
Ele √© armazenado no disco como um <strong>arquivo</strong> execut√°vel (ou conjunto de arquivos) e, quando executado, o Windows carrega o aplicativo na mem√≥ria como um ou mais <strong>processos</strong>.
O c√≥digo do aplicativo, juntamente com seus recursos (<strong>dados</strong>, <strong>bibliotecas</strong>, <strong>etc</strong>), ent√£o √© executado sob a dire√ß√£o do sistema operacional e √© processado pelo <strong>processador</strong>.
H√° uma separa√ß√£o que voc√™ deve entender entre o <strong>arquivo</strong> do <strong>programa</strong> (o c√≥digo) e seu <strong>processo</strong> (a inst√¢ncia em execu√ß√£o).</p>
<p><strong>Subsystem DLLs:</strong></p>
<p>As DLLs de subsistema s√£o bibliotecas de link din√¢mico que implementam os subsistemas em modo de usu√°rio do Windows (explicados abaixo). No Windows, grande parte da funcionalidade fornecida para os aplicativos n√£o est√° embutida no kernel‚Äîela √© oferecida por meio dessas DLLs modulares. Exemplos incluem bibliotecas como <strong><code>kernel32.dll</code></strong>, <strong>user32.dll</strong>, <strong>gdi32.dll</strong>, e outras. Cada uma delas √© projetada para fornecer um conjunto espec√≠fico de servi√ßos, como <strong><code>kernel32.dll</code></strong>, que oferece fun√ß√µes para gerenciamento de mem√≥ria, cria√ß√£o de processos e entrada/sa√≠da de arquivos, <strong>user32.dll</strong>, que implementa componentes de interface do usu√°rio (janelas, mensagens, manipula√ß√£o de entrada), ou <strong>gdi32.dll</strong>, que lida com fun√ß√µes de interface de dispositivo gr√°fico para desenho e gerenciamento de fontes.</p>
<p>Essas DLLs fazem a ponte entre o c√≥digo de aplicativo de alto n√≠vel e o kernel do Windows. Quando um aplicativo faz uma chamada de API para realizar uma tarefa (como abrir uma janela ou ler de um arquivo), normalmente ele chama uma fun√ß√£o em uma dessas DLLs de subsistema. A DLL ent√£o traduz essa solicita√ß√£o em chamadas de sistema de n√≠vel inferior que o kernel pode processar. Esse design modular e em camadas mant√©m o sistema eficiente e mais f√°cil de atualizar.</p>
<p><strong>Windows API</strong>:</p>
<p>A <strong>Windows API</strong> (Interface de Programa√ß√£o de Aplica√ß√µes) √© o conjunto completo de fun√ß√µes, estruturas de dados e conven√ß√µes que a Microsoft exp√µe para permitir que os aplicativos interajam com o Windows. Informalmente conhecida como <strong>Win32</strong> (para a vers√£o de 32 bits) ou simplesmente <strong>Windows API</strong>, √© a forma padr√£o para os desenvolvedores solicitarem servi√ßos do sistema operacional.</p>
<p>A API √© vasta, cobrindo fun√ß√µes para:</p>
<ul>
<li>Gerenciamento de processos, entrada/sa√≠da de arquivos, aloca√ß√£o de mem√≥ria (por exemplo, <strong><code>CreateProcess</code></strong>, <strong><code>ReadFile</code></strong>).</li>
<li>Cria√ß√£o e gerenciamento de janelas, processamento de mensagens, desenho de gr√°ficos (como <strong><code>CreateWindow</code></strong>, <strong><code>MessageBox</code></strong>).</li>
<li><strong>GDI/GDI+</strong> para desenhar texto e imagens.</li>
</ul>
<p><strong>Como Funciona:</strong><br>
Quando voc√™ escreve um aplicativo Windows, inclui arquivos de cabe√ßalho (<strong>windows.h</strong>) que declaram essas fun√ß√µes e tipos. Em tempo de execu√ß√£o, as chamadas do seu aplicativo s√£o encaminhadas atrav√©s do carregador do Windows para a DLL de subsistema apropriada, que ent√£o se comunica com o kernel. Esse fluxo de chamadas do aplicativo, passando pela DLL (usando fun√ß√µes como <strong><code>LoadLibrary</code></strong> e <strong><code>GetProcAddress</code></strong>, se necess√°rio) e finalmente at√© o kernel, √© a espinha dorsal de como o Windows mant√©m o controle enquanto permite que programas de terceiros executem tarefas complexas.</p>
<p>Basicamente, as DLLs de subsistema s√£o as bibliotecas modulares que fornecem os servi√ßos principais do Windows para os aplicativos, isolando-os das intera√ß√µes diretas com o hardware, e a <strong>Windows API</strong> √© o conjunto completo de fun√ß√µes e conven√ß√µes que permitem que os aplicativos solicitem e usem os servi√ßos do Windows, habilitando tarefas desde opera√ß√µes de arquivos at√© o gerenciamento da interface gr√°fica.</p>
<p>Agora que isso est√° claro, vamos entender de fato a Arquitetura do Windows.
Um processador em uma m√°quina rodando o <strong>Windows OS</strong> pode operar em dois modos diferentes:</p>
<p><strong>Modo de Usu√°rio</strong> e <strong>Modo Kernel</strong>, <strong>Aplicativos</strong> rodam em <strong>modo de usu√°rio</strong>, e <strong>componentes do sistema operacional</strong> rodam em <strong>modo kernel</strong>. Quando um aplicativo quer realizar uma tarefa, como criar um arquivo, ele n√£o pode faz√™-lo sozinho. A √∫nica entidade que pode completar a tarefa √© o <strong>Kernel</strong>, ent√£o, em vez disso, os aplicativos devem seguir um <strong>fluxo de chamadas</strong> espec√≠fico.</p>
<p><strong>O que tudo isso significa?</strong></p>
<p><strong>Modo de usu√°rio</strong> √© onde os aplicativos regulares rodam com <strong>privil√©gios limitados</strong>, enquanto <strong>modo kernel</strong> √© onde as <strong>fun√ß√µes centrais do sistema</strong>, como drivers de dispositivo, operam com acesso total ao hardware.</p>
<p><strong>Modo de Usu√°rio vs Modo Kernel</strong></p>
<p><strong>Modo de Usu√°rio:</strong></p>
<p>Aplicativos regulares e a maioria dos processos n√£o cr√≠ticos rodam, e o c√≥digo √© executado com privil√©gios limitados. Por que essa isola√ß√£o ocorre?</p>
<p>Essa isola√ß√£o impede que um aplicativo com falha ou malicioso interfira diretamente no hardware do sistema ou nos servi√ßos centrais, mas, como veremos no futuro, existem formas de contornar isso.
Cada aplicativo rodando em <strong>modo de usu√°rio</strong> √© isolado em seu pr√≥prio espa√ßo de endere√ßo virtual, ent√£o, por exemplo, uma falha ou erro em um processo n√£o necessariamente derrubar√° o sistema inteiro.
Os aplicativos utilizam APIs de alto n√≠vel fornecidas pelas DLLs de subsistema (como <strong><code>kernel32.dll</code></strong>, <strong><code>user32.dll</code></strong>) para realizar tarefas, e estas lidam com o processamento preliminar necess√°rio e ent√£o solicitam servi√ßos ao sistema operacional.</p>
<p><strong>Modo Kernel:</strong></p>
<p>O modo kernel √© a camada de privil√©gios elevados do sistema operacional Windows, onde o Kernel do Windows, drivers de dispositivo e servi√ßos centrais do sistema rodam. O c√≥digo que roda em modo kernel pode acessar diretamente o hardware e a mem√≥ria do sistema.</p>
<p>O modo kernel tem acesso irrestrito, o que √© crucial para realizar opera√ß√µes essenciais como gerenciamento de hardware, aloca√ß√£o de mem√≥ria e opera√ß√µes de entrada/sa√≠da (I/O). Uma falha aqui pode derrubar o sistema inteiro.</p>
<p><strong>Chamadas de Sistema:</strong></p>
<p>Quando um programa em <strong>modo de usu√°rio</strong> precisa acessar o hardware ou realizar opera√ß√µes privilegiadas, ele faz uma chamada de sistema. Isso essencialmente dispara uma solicita√ß√£o que √© processada pelo <strong>modo kernel</strong>.</p>
<p>Para um melhor entendimento, vamos detalhar:</p>
<p><img alt="Windows Architecture" src="https://pwnbuffer.org/images/tteuw/windows_architecture/windows_arch.png"></p>
<p>Ent√£o, os <strong>Processos de Usu√°rio</strong> (programas/aplicativos executados pelo usu√°rio) chamam as <strong>DLLs de Subsistema</strong> (DLLs que cont√™m fun√ß√µes de API chamadas pelos <strong>Processos de Usu√°rio</strong>, como <strong><code>kernel32.dll</code></strong> exportando <strong>CreateFile</strong> da <strong>Windows API</strong>), que ent√£o chamam <strong><code>Ntdll.dll</code></strong> (uma DLL de sistema que √© a camada mais baixa dispon√≠vel em <strong>modo de usu√°rio</strong>. Esta √© uma DLL especial que cria a transi√ß√£o do <strong>modo de usu√°rio</strong> para o <strong>modo kernel</strong>. Isso √© frequentemente referido como a <strong>Native API</strong> ou <strong>NTAPI</strong>), depois chama o <strong>Kernel Executivo</strong> (Isso √© o que √© conhecido como o <strong>Kernel do Windows</strong> e ele chama outros drivers e m√≥dulos dispon√≠veis dentro do <strong>modo kernel</strong> para completar as tarefas. O kernel do Windows est√° parcialmente armazenado em um arquivo chamado <strong>ntoskrnl.exe</strong> sob <strong>&ldquo;C:\Windows\System32&rdquo;</strong>).</p>
<p>Como essa transi√ß√£o de <strong>modo de usu√°rio</strong> para <strong>modo kernel</strong> funciona?</p>
<p>Essa transi√ß√£o faz parte do que √© conhecido como <strong>Fluxo de Chamadas de Fun√ß√µes</strong>:</p>
<p>Essencialmente, quando um programa em <strong>modo de usu√°rio</strong> faz uma chamada de sistema (como ler um arquivo), a CPU precisa mudar para o <strong>modo kernel</strong> para acessar recursos protegidos. A transi√ß√£o normalmente acontece por meio de uma interrup√ß√£o ou mecanismo de chamada de sistema. Isso permite que o sistema operacional gerencie a√ß√µes privilegiadas com seguran√ßa, garantindo que os programas de usu√°rio n√£o interfiram diretamente nas opera√ß√µes de baixo n√≠vel do sistema.</p>
<p>Passo a passo:</p>
<p><strong>Processos de Usu√°rio:</strong><br>
Um processo em <strong>modo de usu√°rio</strong> (um aplicativo) come√ßa em <strong>modo de usu√°rio</strong> e chama uma fun√ß√£o de <strong>Windows API</strong> de alto n√≠vel. Por exemplo, quando seu aplicativo chama <strong>CreateFile</strong> (de <strong><code>kernel32.dll</code></strong>), ele est√° invocando uma fun√ß√£o fornecida por uma DLL de subsistema.</p>
<p><strong>DLLs de Subsistema:</strong><br>
As DLLs de subsistema (como <strong><code>kernel32.dll</code></strong>, <strong>user32.dll</strong>, etc.) fornecem as fun√ß√µes de API que o aplicativo usa. Essas DLLs cont√™m &ldquo;wrappers&rdquo; que configuram a chamada e depois invocam rotinas de n√≠vel inferior conforme necess√°rio. No caso de fun√ß√µes como <strong>CreateFile</strong>, a DLL faz o &ldquo;wrapper&rdquo; da chamada e depois delega para uma camada inferior.</p>
<p><strong><code>Ntdll.dll</code> (<strong>Native API</strong>):</strong><br>
O pr√≥ximo passo envolve <strong><code>ntdll.dll</code></strong>. Esta DLL especial de sistema global fica na parte inferior da camada de <strong>modo de usu√°rio</strong> e cont√©m os &ldquo;stubs&rdquo; de chamadas de sistema (parte disso) que s√£o as rotinas (frequentemente chamadas de <strong>Native API</strong> ou <strong>NTAPI</strong>) que preparam a transi√ß√£o de <strong>modo de usu√°rio</strong> para <strong>modo kernel</strong>. Essencialmente, quando uma <strong>DLL de subsistema</strong> chama <strong>ntdll.dll</strong>, ela est√° configurando uma chamada de sistema que a CPU pode executar para mudar para o modo kernel.</p>
<p><strong>Kernel Executivo (ntoskrnl.exe e drivers):</strong><br>
Uma vez que a chamada de sistema √© emitida (usando instru√ß√µes como <strong>syscall</strong> ou <strong>sysenter</strong>), a CPU muda para o modo kernel. A solicita√ß√£o √© ent√£o processada pelo kernel do Windows (principalmente em <strong>ntoskrnl.exe</strong>, que faz parte do Kernel Executivo). O kernel executa a opera√ß√£o solicitada chamando os drivers e m√≥dulos do kernel apropriados para completar a tarefa.</p>
<p><strong>Caminho de Retorno:</strong><br>
Ap√≥s o kernel completar a opera√ß√£o, o resultado √© passado de volta atrav√©s do <strong>ntdll.dll</strong> para as <strong>DLLs de subsistema</strong>, que por sua vez retornam o resultado para o processo original em <strong>modo de usu√°rio</strong>.</p>
<p>Ent√£o, para consolidar, come√ßa com o aplicativo de usu√°rio chamando a fun√ß√£o <strong>WinAPI CreateFile</strong>, que est√° dispon√≠vel em <strong>kernel32.dll</strong>. <strong>Kernel32.dll</strong> √© uma DLL cr√≠tica que exp√µe as aplica√ß√µes √† WinAPI e, portanto, pode ser vista carregada pela maioria das aplica√ß√µes. Em seguida, <strong>CreateFile</strong> chama sua fun√ß√£o equivalente <strong>NTAPI</strong>, <strong>NtCreateFile</strong>, que √© fornecida atrav√©s de <strong>ntdll.dll</strong>. <strong>Ntdll.dll</strong> ent√£o executa uma instru√ß√£o de assembly <strong>sysenter (x86)</strong> ou <strong>syscall (x64)</strong>, que transfere a execu√ß√£o para o <strong>modo kernel</strong>. A fun√ß√£o kernel <strong>NtCreateFile</strong> √© ent√£o utilizada, chamando drivers e m√≥dulos do kernel para realizar a tarefa solicitada.</p>
<p><strong>Invocando Diretamente a <strong>Native API</strong> (NTAPI)</strong><br>
√â importante observar que as aplica√ß√µes podem invocar syscalls (fun√ß√µes <strong>NTDLL</strong>) diretamente, sem precisar passar pela <strong>Windows API</strong>. A <strong>Windows API</strong> simplesmente atua como um &ldquo;wrapper&rdquo; para a <strong>Native API</strong>. Dito isso, a <strong>Native API</strong> √© mais dif√≠cil de usar porque n√£o √© oficialmente documentada pela Microsoft.</p>
<p>Normalmente, as aplica√ß√µes usam a <strong>Windows API</strong> (como <strong>CreateFile</strong>, <strong>WriteFile</strong>), que √© fornecida por DLLs como <strong>kernel32.dll</strong>.</p>
<p>Chamar diretamente fun√ß√µes nativas de <strong>ntdll.dll</strong> (fun√ß√µes <strong>NTAPI</strong>) √© poss√≠vel.</p>
<p>A <strong>Windows API</strong> √© uma interface est√°vel e documentada, usada pela maioria dos aplicativos e constru√≠da em cima da <strong>Native API</strong> (<strong>NTAPI</strong>, em <strong>ntdll.dll</strong>). Fun√ß√µes <strong>NTAPI</strong> s√£o os &ldquo;stubs&rdquo; de chamadas de sistema que lidam com tarefas em n√≠vel de sistema, fazendo a transi√ß√£o para o modo kernel.</p>
<p><strong>Como o empacotamento funciona:</strong><br>
Quando voc√™ chama uma fun√ß√£o como <code>CreateFile</code> de <code>kernel32.dll</code>, voc√™ n√£o est√° invocando diretamente as rotinas de sistema de n√≠vel mais baixo. Em vez disso, <code>CreateFile</code> prepara os par√¢metros e chama uma fun√ß√£o correspondente em <code>ntdll.dll</code> (como <code>NtCreateFile</code>).</p>
<p><img alt="Function Call Flow" src="https://pwnbuffer.org/images/tteuw/windows_architecture/func_call_flow.png"></p>
<p>O fluxo de transi√ß√µes funciona da seguinte maneira:</p>
<ol>
<li><strong>Processo do Usu√°rio:</strong> Seu aplicativo chama <code>CreateFile</code> em <code>kernel32.dll</code>.</li>
<li><strong><code>Kernel32.dll</code>:</strong> Esta fun√ß√£o realiza qualquer verifica√ß√£o de par√¢metros, tradu√ß√£o de erros ou trabalho de compatibilidade e, em seguida, chama a fun√ß√£o nativa (<code>NtCreateFile</code>) em <code>ntdll.dll</code>.</li>
<li><strong><code>Ntdll.dll</code> (NTAPI):</strong> Aqui, a fun√ß√£o emite a chamada de sistema real (usando instru√ß√µes da CPU como <code>syscall</code> ou <code>sysenter</code>) que faz a transi√ß√£o da execu√ß√£o de <strong>modo de usu√°rio</strong> para <strong>modo kernel</strong>.</li>
<li><strong>Modo Kernel:</strong> O kernel do Windows (<code>ntoskrnl.exe</code>) processa a solicita√ß√£o, interage com os drivers e completa a opera√ß√£o.</li>
<li><strong>Caminho de Retorno:</strong> O resultado flui de volta da mesma forma, eventualmente retornando ao seu aplicativo.</li>
</ol>
<p>Pode soar um pouco repetitivo, mas √© realmente importante para voc√™ entender isso.</p>
<h1 id="gerenciamento-de-mem√≥ria-no-windows">
  Gerenciamento de Mem√≥ria no Windows
  <a class="heading-link" href="#gerenciamento-de-mem%c3%b3ria-no-windows">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link para o cabe√ßalho"></i>
    <span class="sr-only">Link para o cabe√ßalho</span>
  </a>
</h1>
<p>O gerenciamento de mem√≥ria √© um componente cr√≠tico de qualquer sistema operacional, e o Windows n√£o √© exce√ß√£o. O gerenciador de mem√≥ria do Windows √© respons√°vel por lidar com a aloca√ß√£o de mem√≥ria, mem√≥ria virtual, pagina√ß√£o e outras opera√ß√µes de baixo n√≠vel que garantem o uso eficiente da mem√≥ria por aplicativos em modo de usu√°rio e pelo kernel.</p>
<h2 id="mem√≥ria-virtual">
  Mem√≥ria Virtual
  <a class="heading-link" href="#mem%c3%b3ria-virtual">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link para o cabe√ßalho"></i>
    <span class="sr-only">Link para o cabe√ßalho</span>
  </a>
</h2>
<p>O Windows emprega um sistema de <strong>mem√≥ria virtual</strong> que fornece a cada processo seu pr√≥prio espa√ßo de endere√ßamento virtual. Essa abstra√ß√£o permite que os aplicativos operem como se tivessem um bloco cont√≠guo de mem√≥ria, mesmo que a mem√≥ria f√≠sica real esteja fragmentada ou mesmo parcialmente armazenada no disco.</p>
<ul>
<li>Cada processo em <strong>modo de usu√°rio</strong> possui um <strong>espa√ßo de endere√ßamento virtual</strong> de 4GB (para sistemas de 32 bits) ou significativamente maior em sistemas de 64 bits.</li>
<li>A metade inferior do espa√ßo de endere√ßamento (0x00000000 a 0x7FFFFFFF em 32 bits) √© reservada para o aplicativo, enquanto a metade superior (0x80000000 a 0xFFFFFFFF) √© reservada para o kernel.</li>
<li>O <strong>Gerenciador de Mem√≥ria</strong> √© respons√°vel por traduzir endere√ßos virtuais em endere√ßos f√≠sicos usando <strong>tabelas de p√°ginas</strong>.</li>
</ul>
<h2 id="pagina√ß√£o-e-falhas-de-p√°gina">
  Pagina√ß√£o e Falhas de P√°gina
  <a class="heading-link" href="#pagina%c3%a7%c3%a3o-e-falhas-de-p%c3%a1gina">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link para o cabe√ßalho"></i>
    <span class="sr-only">Link para o cabe√ßalho</span>
  </a>
</h2>
<p>O <strong>gerenciador de mem√≥ria do Windows</strong> utiliza uma t√©cnica chamada <strong>pagina√ß√£o</strong> para gerenciar a mem√≥ria de forma eficiente:</p>
<ul>
<li>O sistema divide a mem√≥ria em <strong>p√°ginas</strong> de tamanho fixo (geralmente 4KB).</li>
<li>Quando um aplicativo solicita mem√≥ria, s√£o atribu√≠das p√°ginas da <strong>mem√≥ria f√≠sica (RAM)</strong>.</li>
<li>Se uma p√°gina solicitada n√£o estiver na RAM, ocorre uma <strong>falha de p√°gina</strong>, e o Windows carrega a p√°gina do disco (arquivo de pagina√ß√£o ou outra fonte de armazenamento).</li>
<li>O <strong>arquivo de pagina√ß√£o</strong> (<code>pagefile.sys</code>) √© utilizado quando a RAM √© insuficiente, permitindo que as p√°ginas de mem√≥ria sejam temporariamente armazenadas no disco.</li>
</ul>
<p><strong>Tratamento de Falhas de P√°gina:</strong></p>
<ol>
<li>A CPU tenta acessar uma p√°gina de mem√≥ria.</li>
<li>Se a p√°gina n√£o estiver na mem√≥ria f√≠sica, ocorre uma <strong>falha de p√°gina</strong>.</li>
<li>O gerenciador de mem√≥ria recupera a p√°gina do disco e a mapeia para a mem√≥ria f√≠sica.</li>
<li>O processo retoma a execu√ß√£o assim que a p√°gina estiver dispon√≠vel.</li>
</ol>
<h2 id="randomiza√ß√£o-de-layout-de-espa√ßo-de-endere√ßamento-aslr">
  Randomiza√ß√£o de Layout de Espa√ßo de Endere√ßamento (ASLR)
  <a class="heading-link" href="#randomiza%c3%a7%c3%a3o-de-layout-de-espa%c3%a7o-de-endere%c3%a7amento-aslr">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link para o cabe√ßalho"></i>
    <span class="sr-only">Link para o cabe√ßalho</span>
  </a>
</h2>
<p><strong>ASLR</strong> √© um recurso de seguran√ßa que randomiza os endere√ßos de mem√≥ria usados por componentes do sistema e aplicativos para dificultar que atacantes prevejam endere√ßos na mem√≥ria.</p>
<ul>
<li><strong>Imagens execut√°veis</strong> (por exemplo, <code>ntdll.dll</code>, <code>kernel32.dll</code>) s√£o carregadas em locais aleat√≥rios.</li>
<li><strong>Aloca√ß√µes de pilha e heap</strong> s√£o randomizadas.</li>
<li>Isso impede layouts de mem√≥ria previs√≠veis, dificultando que exploits como <strong>buffer overflows</strong> e <strong>ataques de programa√ß√£o orientada a retorno (ROP)</strong> tenham sucesso.</li>
</ul>
<h2 id="gerenciamento-de-heap-e-pilha">
  Gerenciamento de Heap e Pilha
  <a class="heading-link" href="#gerenciamento-de-heap-e-pilha">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link para o cabe√ßalho"></i>
    <span class="sr-only">Link para o cabe√ßalho</span>
  </a>
</h2>
<p>O Windows gerencia a mem√≥ria usando duas estruturas principais:</p>
<h3 id="a-pilha">
  A Pilha
  <a class="heading-link" href="#a-pilha">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link para o cabe√ßalho"></i>
    <span class="sr-only">Link para o cabe√ßalho</span>
  </a>
</h3>
<ul>
<li>Usada para chamadas de fun√ß√µes e vari√°veis locais.</li>
<li>Gerida automaticamente pela CPU e pelo sistema operacional.</li>
<li>Tem um tamanho fixo, tipicamente 1MB no Windows.</li>
<li><strong>Overflow de Pilha</strong> ocorre quando muita mem√≥ria √© usada, frequentemente devido a chamadas de fun√ß√µes recursivas.</li>
</ul>
<h3 id="o-heap">
  O Heap
  <a class="heading-link" href="#o-heap">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link para o cabe√ßalho"></i>
    <span class="sr-only">Link para o cabe√ßalho</span>
  </a>
</h3>
<ul>
<li>Usado para aloca√ß√£o din√¢mica de mem√≥ria (<code>malloc</code>, <code>HeapAlloc</code>, <code>VirtualAlloc</code>).</li>
<li>Gerido pelo gerenciador de heap do Windows.</li>
<li>Pode crescer conforme necess√°rio.</li>
<li>Aplica√ß√µes s√£o respons√°veis por liberar a mem√≥ria do heap (<code>free</code>, <code>HeapFree</code>).</li>
</ul>
<h2 id="apis-de-mem√≥ria-do-windows">
  APIs de Mem√≥ria do Windows
  <a class="heading-link" href="#apis-de-mem%c3%b3ria-do-windows">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link para o cabe√ßalho"></i>
    <span class="sr-only">Link para o cabe√ßalho</span>
  </a>
</h2>
<p>O Windows oferece v√°rias APIs para gerenciamento de mem√≥ria:</p>
<ul>
<li><strong>VirtualAlloc/VirtualFree</strong> ‚Äì Aloca e libera p√°ginas de mem√≥ria diretamente.</li>
<li><strong>HeapAlloc/HeapFree</strong> ‚Äì Gerencia a mem√≥ria din√¢mica no heap do processo.</li>
<li><strong>GlobalAlloc/LocalAlloc</strong> ‚Äì Fun√ß√µes legadas para alocar mem√≥ria.</li>
<li><strong>MapViewOfFile</strong> ‚Äì Usado para arquivos mapeados na mem√≥ria.</li>
</ul>
<h2 id="gerenciamento-de-mem√≥ria-em-modo-kernel">
  Gerenciamento de Mem√≥ria em Modo Kernel
  <a class="heading-link" href="#gerenciamento-de-mem%c3%b3ria-em-modo-kernel">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link para o cabe√ßalho"></i>
    <span class="sr-only">Link para o cabe√ßalho</span>
  </a>
</h2>
<p>O gerenciamento de mem√≥ria em modo kernel √© mais privilegiado e opera de forma diferente:</p>
<ul>
<li>O kernel usa mem√≥ria de <strong>pool de p√°ginas</strong> e <strong>pool n√£o paginado</strong>.</li>
<li><strong>Pool de P√°ginas</strong> ‚Äì Pode ser trocado para o disco.</li>
<li><strong>Pool N√£o Paginado</strong> ‚Äì Permanece na RAM, usado para componentes cr√≠ticos como drivers.</li>
<li>O kernel usa <strong>Listas de Descritores de Mem√≥ria (MDLs)</strong> para rastrear regi√µes de mem√≥ria.</li>
<li>O Windows usa <strong>IRQLs (N√≠veis de Solicita√ß√£o de Interrup√ß√£o)</strong> para gerenciar o acesso priorit√°rio √† mem√≥ria.</li>
</ul>

      </div>


      <footer>
        

<section class="see-also">
  
    
    
    
  
</section>


        
        
        
        
        
        
        
      </footer>
    </article>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css"
    integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">
  
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"
    integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"
    integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body,
      {
        delimiters: [
          {left: '$$', right: '$$', display:true},
          {left: '$', right: '$', display:false},
          {left: '\\(', right: '\\)', display: false},
          {left: '\\[', right: '\\]', display: true}
        ]
      }
    );"></script>
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ¬©
    
    2025
     pwnbuffer 
    ¬∑
    
    Promovido por <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/" target="_blank" rel="noopener">Coder (modified)</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="https://pwnbuffer.org/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js" integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
  

  

  


  
  



  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
</body>
</html>
